<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory Architect: Group Edition</title>
    <style>
        :root {
            --bg: #1f2222;
            --card: #282828;
            --card-dark: #202020;
            --text: #ede4bd;
            --grey: #ede4bd2f;
            --accent: #b16f09;
            --success: #698114;
            --danger: #b93220;
            --edit: #5286b9;
            --secondary: #986073;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        body::-webkit-scrollbar {
            display: none;
        }

        .container {
            width: 100%;
            max-width: 900px;
        }

        .card {
            background: var(--card);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--grey);
            position: relative;
            transition: 0.3s;
        }

        h1 {
            margin-bottom: 30px;
            border-bottom: 2px solid var(--accent);
            display: inline-block;
            padding-bottom: 5px;
        }

        h2 {
            margin-top: 0;
            color: var(--text);
            font-size: 1.2em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .input-group {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        input,
        select,
        button {
            padding: 10px;
            border-radius: 4px;
            border: none;
            outline: none;
        }

        input {
            background: var(--card-dark);
            color: white;
            flex: 1;
            min-width: 140px;
        }

        button {
            cursor: pointer;
            background: var(--accent);
            color: white;
            font-weight: bold;
            transition: 0.2s;
        }

        button:hover {
            opacity: 0.8;
        }

        /* Recipe Grid Styling */
        .recipe-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .recipe-card {
            background: var(--card-dark);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--accent);
            position: relative;
            font-size: 0.85em;
        }

        .control-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            opacity: 0.5;
        }

        .control-btn:hover {
            opacity: 1;
            color: var(--danger);
        }

        /* Group Block Styling */
        .group-item {
            background: var(--card-dark);
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--grey);
        }

        /* Results Styling */
        #results {
            background: var(--card-dark);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--success);
            display: none;
            margin-top: 20px;
        }

        .group-result-block {
            border-left: 2px solid var(--secondary);
            padding-left: 15px;
            margin-bottom: 30px;
        }

        .group-result-header {
            color: var(--secondary);
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-decoration: underline;
        }

        .summary-box {
            background: #111;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            border: 1px solid var(--accent);
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--success);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        .card.editing {
            border-color: var(--edit);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.3);
        }

        #saveBtn.editing {
            background: var(--edit);
        }

        .control-btn.edit-btn:hover {
            color: var(--edit);
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>üèóÔ∏è Factory Architect: Group Edition</h1>

        <div class="card">
            <h2>1. Machine Recipes</h2>
            <div class="input-group">
                <input type="hidden" id="editId">
                <input type="text" id="mName" placeholder="Machine Name">
                <input type="number" id="mTime" placeholder="Process Time (s)">
                <input type="number" id="mPower" placeholder="Power (KW)">
                <input type="number" id="mCost" placeholder="Build Cost ($)">
            </div>
            <div class="input-group">
                <input type="text" id="mInputs" placeholder="Inputs (e.g. 2 coal, 6 water)">
                <input type="text" id="mOutputs" placeholder="Outputs (e.g. 1 steel ingot)">
            </div>
            <button onclick="addRecipe()" style="width: 100%;">üíæ Save Recipe</button>
            <div id="recipeDisplay" class="recipe-grid"></div>
            <div class="input-group" style="margin-top: 10px;">
                <button onclick="exportData()" style="background: var(--secondary); flex: 1;">üì§ Export Data</button>
                <button onclick="importData()" style="background: var(--edit); flex: 1;">üì• Import Data</button>
                <button onclick="deleteAllRecipes()" style="background: var(--danger); flex: 1;">üóëÔ∏è Delete All</button>
            </div>
        </div>

        <div class="card">
            <h2>2. Production Groups</h2>
            <div class="input-group">
                <input type="text" id="gName" placeholder="Group Name (e.g. Crankshaft Line)">
                <input type="text" id="gTarget" placeholder="Target Item">
                <input type="number" id="gQty" placeholder="Quantity">
                <input type="number" id="gTime" placeholder="Over Time (s)">
            </div>
            <div class="input-group">
                <input type="text" id="gInputs"
                    placeholder="Supplied Inputs (e.g. steel ingot, coke fuel) - Will not spawn machines">
                <button onclick="addGroup()" style="background: var(--edit);">‚ûï Add Group</button>
            </div>

            <div id="groupList" style="margin-top: 15px;"></div>

            <div class="input-group" style="margin-top: 20px; border-top: 1px solid var(--grey); padding-top: 15px;">
                <input type="number" id="currentBank" placeholder="Current Bank Balance" value="30000000">
                <button onclick="autoGroup()" style="background: var(--edit); flex: 1;">ü§ñ Auto-Group</button>
                <button onclick="calculateAll()" style="background: var(--success); flex: 2; font-size: 1.1em;">üöÄ Run
                    Full Simulation</button>
            </div>
        </div>

        <div id="results">
            <h2 style="color: var(--success);">üìä Deployment Blueprint</h2>
            <div
                style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; font-weight: bold; color: var(--text);">
                <label class="switch">
                    <input type="checkbox" id="advancedToggle" onchange="calculateAll()">
                    <span class="slider"></span>
                </label>
                <span>Advanced View (Show Rates)</span>
            </div>
            <div id="machineList"></div>
            <div id="summaryList" class="summary-box"></div>
        </div>
    </div>

    <script>
        let recipes = JSON.parse(localStorage.getItem('factoryRecipes')) || [];
        let groups = JSON.parse(localStorage.getItem('factoryGroups')) || [];

        window.onload = () => { displayRecipes(); displayGroups(); };

        // Function to download your database and groups as a JSON file
        function exportData() {
            const data = {
                recipes: recipes,
                groups: groups
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `factory_recipe_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Function to trigger a file upload and update the local database
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (imported.recipes) recipes = imported.recipes;
                        if (imported.groups) groups = imported.groups;

                        saveData();
                        displayRecipes();
                        displayGroups();
                        alert("Import Successful!");
                    } catch (err) {
                        alert("Error importing file: Invalid JSON format.");
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function addRecipe() {
            const editId = document.getElementById('editId').value;
            const id = editId || Date.now();
            const name = document.getElementById('mName').value.trim();
            const time = parseFloat(document.getElementById('mTime').value);

            if (!name || !time) return alert("Machine Name and Time are required!");

            const recipeData = {
                id: id,
                name: name,
                inputs: parseItems(document.getElementById('mInputs').value, time),
                outputs: parseItems(document.getElementById('mOutputs').value, time),
                origTime: time,
                power: parseFloat(document.getElementById('mPower').value) || 0,
                cost: parseFloat(document.getElementById('mCost').value) || 0,
                rawIn: document.getElementById('mInputs').value,
                rawOut: document.getElementById('mOutputs').value
            };

            const existingIdx = recipes.findIndex(r => r.id == id);
            if (existingIdx > -1) {
                recipes[existingIdx] = recipeData;
            } else {
                recipes.push(recipeData);
            }

            saveData();
            displayRecipes();
            resetRecipeForm();
        }

        function resetRecipeForm() {
            ['mName', 'mTime', 'mPower', 'mCost', 'mInputs', 'mOutputs', 'editId'].forEach(id => document.getElementById(id).value = '');
            document.querySelector('.card').classList.remove('editing');
            document.getElementById('saveBtn').classList.remove('editing');
            document.getElementById('saveBtn').innerText = "üíæ Save to Database";
        }

        function editRecipe(id) {
            const r = recipes.find(rec => rec.id == id);
            if (!r) return;

            document.getElementById('editId').value = r.id;
            document.getElementById('mName').value = r.name;
            document.getElementById('mTime').value = r.origTime;
            document.getElementById('mPower').value = r.power;
            document.getElementById('mCost').value = r.cost;
            document.getElementById('mInputs').value = r.rawIn;
            document.getElementById('mOutputs').value = r.rawOut;

            // UI Feedback
            document.querySelector('.card').classList.add('editing');
            document.getElementById('saveBtn').classList.add('editing');
            document.getElementById('saveBtn').innerText = "Update Machine";
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function parseItems(str, time) {
            const obj = {};
            if (!str) return obj;
            str.split(',').forEach(p => {
                const parts = p.trim().split(' ');
                const qty = parseFloat(parts[0]);
                const item = parts.slice(1).join(' ').toLowerCase().trim();
                if (item) obj[item] = qty / time;
            });
            return obj;
        }

        function addGroup() {
            const name = document.getElementById('gName').value.trim();
            const item = document.getElementById('gTarget').value.toLowerCase().trim();
            const qty = parseFloat(document.getElementById('gQty').value);
            const time = parseFloat(document.getElementById('gTime').value);
            // Parse the inputs into an array
            const inputs = document.getElementById('gInputs').value.split(',').map(i => i.trim().toLowerCase()).filter(i => i);

            if (!name || !item || isNaN(qty)) return alert("Fill Group Name, Target, and Quantity!");

            groups.push({ id: Date.now(), name, item, qty, time, inputs });
            localStorage.setItem('factoryGroups', JSON.stringify(groups));
            displayGroups();

            // Clear the form
            ['gName', 'gTarget', 'gQty', 'gInputs'].forEach(id => document.getElementById(id).value = '');
        }

        function autoGroup() {
            const targetItem = document.getElementById('gTarget').value.toLowerCase().trim();
            const totalQty = parseFloat(document.getElementById('gQty').value);
            const totalTime = parseFloat(document.getElementById('gTime').value);

            if (!targetItem || isNaN(totalQty)) return alert("Enter a Target Item and Quantity first!");

            if (groups.length > 0 && !confirm("Clear existing groups and auto-generate new ones?")) return;
            groups = [];

            let processed = new Set();
            let queue = [{ item: targetItem, qty: totalQty, time: totalTime }];

            while (queue.length > 0) {
                let current = queue.shift();
                if (processed.has(current.item)) continue;

                // Stop if the item is a base raw resource (no recipes found)
                let producers = findAllProducers(current.item);
                if (producers.length === 0) continue;

                processed.add(current.item);

                // 1. Run simulation to analyze the internal dependency structure
                let sim = runLogic(current.item, current.qty, current.time, []);

                // 2. Identify SHARED items:
                // An item is shared if it is consumed by 2 or more DIFFERENT product-lines.
                let sharedInputs = [];
                for (let ingredient in sim.flowTotals) {
                    let consumers = new Set();

                    // Check treeData to see which items are being produced using this ingredient
                    for (let productProduced in sim.treeData) {
                        sim.treeData[productProduced].forEach(node => {
                            if (node.inputs.some(i => i.itemName === ingredient)) {
                                consumers.add(productProduced);
                            }
                        });
                    }

                    // Rule: If 2+ different products need this, it becomes a Group Input [RAW]
                    if (consumers.size >= 2) {
                        sharedInputs.push(ingredient);
                    }
                }

                // 3. Create the group for this stage
                groups.push({
                    id: Date.now() + Math.random(),
                    name: `${current.item.toUpperCase()} GROUP`,
                    item: current.item,
                    qty: current.qty,
                    time: current.time,
                    inputs: sharedInputs
                });

                // 4. Recurse: Shared items become the starting point for the next groups
                sharedInputs.forEach(si => {
                    // Use the total flow rate calculated in the simulation
                    queue.push({ item: si, qty: sim.flowTotals[si], time: 1 });
                });
            }

            saveData();
            displayGroups();
            alert(`Auto-Group Complete! Generated ${groups.length} optimized stages.`);
        }

        function calculateAll() {
            const container = document.getElementById('machineList'); // Reusing existing ID for convenience
            container.innerHTML = "";
            document.getElementById('results').style.display = 'block';

            let grandPower = 0;
            let grandCost = 0;

            groups.forEach(group => {
                const data = runLogic(group.item, group.qty, group.time, group.inputs);
                grandPower += data.totalPwr;
                grandCost += data.totalCost;

                const section = document.createElement('div');
                section.style.marginBottom = "40px";
                section.innerHTML = `<div style="color:var(--secondary); font-weight:bold; border-bottom:1px solid var(--secondary); margin-bottom:15px;">üì¶ GROUP: ${group.name.toUpperCase()}</div>`;
                section.innerHTML += renderNode(data.treeData, group.item, data.flowTotals[group.item], data.flowTotals, 0);
                container.appendChild(section);
            });

            const bank = parseFloat(document.getElementById('currentBank').value) || 0;
            const remaining = bank - grandCost;
            document.getElementById('summaryList').innerHTML = `
        <div style="color:var(--accent)">‚ö° Total Factory Power: <b>${grandPower.toLocaleString()} KW</b></div>
        <div style="color:var(--danger)">üí∞ Total Build Cost: <b>$${grandCost.toLocaleString()}</b></div>
        <div style="font-size:1.2em; margin-top:10px; color:${remaining >= 0 ? 'var(--success)' : 'var(--danger)'}">
            üè¶ Remaining Bank: <b>$${remaining.toLocaleString()}</b>
        </div>
    `;
        }

        function runLogic(target, qty, time, groupInputs) {
            let totalPwr = 0, totalCost = 0;
            let pending = { [target]: qty / time };
            let flowTotals = { [target]: qty / time };
            let treeData = {};
            let toProcess = [target];
            const EPSILON = 1e-9;

            while (toProcess.length > 0) {
                const item = toProcess.shift();
                let amountNeeded = pending[item];
                if (amountNeeded <= EPSILON) continue;

                // STOP RULE: If this item is a "Supplied Input" for this group, don't find machines
                if (groupInputs.includes(item)) {
                    continue;
                }

                pending[item] = 0;
                let producers = findAllProducers(item); // Uses your existing search function

                if (producers.length > 0) {
                    let p = producers[0].fullRecipe; // Simplification: pick first producer
                    let machinesNeeded = Math.ceil((amountNeeded / producers[0].rate) - EPSILON);

                    totalPwr += (p.power || 0) * machinesNeeded;
                    totalCost += (p.cost || 0) * machinesNeeded;

                    if (!treeData[item]) treeData[item] = [];
                    let node = {
                        machine: p.name,
                        count: machinesNeeded,
                        allOutputs: p.outputs,
                        inputs: []
                    };

                    for (let input in p.inputs) {
                        let rate = p.inputs[input] * (amountNeeded / producers[0].rate);
                        pending[input] = (pending[input] || 0) + rate;
                        flowTotals[input] = (flowTotals[input] || 0) + rate;
                        node.inputs.push({ itemName: input, rate: rate });
                        if (!toProcess.includes(input)) toProcess.push(input);
                    }
                    treeData[item].push(node);
                }
            }
            return { treeData, flowTotals, totalPwr, totalCost };
        }

        function renderNode(treeData, itemName, requiredRate, flowTotals, depth, isLast = true, prefix = "") {
            const connector = depth === 0 ? "" : (isLast ? "‚îî‚îÄ " : "‚îú‚îÄ ");
            const newPrefix = depth === 0 ? "" : prefix + (isLast ? "&nbsp;&nbsp;&nbsp;&nbsp;" : "‚îÇ&nbsp;&nbsp;&nbsp;");
            const inPrefix = depth === 0 ? "" : prefix + (isLast ? "&nbsp;&nbsp;&nbsp;" : "‚îÇ&nbsp;&nbsp;");
            const isAdvanced = document.getElementById('advancedToggle').checked;

            if (!treeData[itemName]) {
                const displayVal = isAdvanced ? `${requiredRate.toFixed(3)} ${itemName}/s` : itemName;

                // --- NEW LOGIC: IDENTIFY SOURCE GROUP ---
                // Find if any existing group produces this item
                const sourceGroup = groups.find(g => g.item.toLowerCase() === itemName.toLowerCase());
                const sourceText = sourceGroup
                    ? ` ‚Äî <small style="color:var(--secondary)">from group: <b>${sourceGroup.name.toUpperCase()}</b></small>`
                    : "";

                return `<div style="font-family: monospace; white-space: nowrap; margin-bottom: 8px; font-size: 16px">
                    <span style="color: #666;">${prefix}${connector}</span>
                    <span style="color:#3498db;">[RAW] ${displayVal}</span>${sourceText}
                </div>`;
            }

            let html = "";
            treeData[itemName].forEach((node) => {
                let outputStrings = [];
                for (let out in node.allOutputs) {
                    const totalRate = (node.allOutputs[out] * node.count).toFixed(3);
                    outputStrings.push(isAdvanced ? `${totalRate} ${out}/s` : out);
                }

                let inputStrings = node.inputs.map(inp => isAdvanced ? `${inp.rate.toFixed(3)} ${inp.itemName}/s` : inp.itemName);

                html += `<div style="font-family: monospace; white-space: nowrap; margin-bottom: 0px; font-size: 16px">
                    <span style="color: #666;">${prefix}${connector}</span>
                    <b style="color:var(--accent)">${node.count}x</b> <b style="color:var(--text)">${node.machine.toUpperCase()}</b>
                </div>
                <div style="font-family: monospace; white-space: nowrap; margin-bottom: 0px; font-size: 16px; opacity: 0.9;">
                    <span style="color: #666;">${inPrefix}</span>
                    <span style="color: var(--success); font-weight: 900;">‚îÇOUT:</span> ${outputStrings.join(', ')}
                </div>
                <div style="font-family: monospace; white-space: nowrap; margin-bottom: 8px; font-size: 16px; opacity: 0.9;">
                    <span style="color: #666;">${inPrefix}</span>
                    <span style="color: var(--danger); font-weight: 900;">‚îÇIN :</span> ${inputStrings.length ? inputStrings.join(', ') : 'NONE'}
                </div>`;

                node.inputs.forEach((input, idx) => {
                    html += renderNode(treeData, input.itemName, input.rate, flowTotals, depth + 1, idx === node.inputs.length - 1, newPrefix);
                });
            });
            return html;
        }

        function displayRecipes() {
            const div = document.getElementById('recipeDisplay');
            div.innerHTML = recipes.map(r => `
                <div class="recipe-card">
                    <div class="control-btn" style="position:absolute; top:5px; right:5px; display:flex; gap:10px;">
                        <span onclick="editRecipe(${r.id})" style="cursor:pointer;">‚úèÔ∏è</span>
                        <span onclick="deleteRecipe(${r.id})" style="cursor:pointer;">‚úñ</span>
                    </div>
                    <strong>${r.name.toUpperCase()}</strong><br>
                    <small style="opacity:0.7">üì• In: ${r.rawIn || 'None'} | üì§ Out: ${r.rawOut}</small>
                </div>
            `).join('');
        }

        function displayGroups() {
            const div = document.getElementById('groupList');
            div.innerHTML = groups.map(g => `
        <div class="recipe-card" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
            <div>
                <strong>${g.name}</strong><br>
                <small>Target: ${g.qty} ${g.item} | Inputs: ${g.inputs.join(', ') || 'None'}</small>
            </div>
            <button onclick="deleteGroup(${g.id})" style="background:var(--danger); padding:2px 8px;">X</button>
        </div>
    `).join('');
        }

        function deleteAllRecipes() {
            if (confirm("Are you sure you want to delete ALL recipes? This cannot be undone.")) {
                recipes = [];
                saveData();
                displayRecipes();
            }
        }

        // FIXED: Added String() conversion to prevent type mismatch
        function deleteRecipe(id) {
            recipes = recipes.filter(r => String(r.id) !== String(id));
            saveData();
            displayRecipes();
        }

        // FIXED: Added String() conversion for groups as well
        function deleteGroup(id) {
            groups = groups.filter(g => String(g.id) !== String(id));
            localStorage.setItem('factoryGroups', JSON.stringify(groups));
            displayGroups();
        }

        function saveData() {
            localStorage.setItem('factoryRecipes', JSON.stringify(recipes));
            localStorage.setItem('factoryGroups', JSON.stringify(groups));
        }

        function findAllProducers(itemName) {
            let producers = [];
            recipes.forEach(r => {
                if (r.outputs[itemName]) {
                    producers.push({
                        fullRecipe: r,
                        rate: r.outputs[itemName]
                    });
                }
            });
            return producers;
        }
    </script>
</body>

</html>